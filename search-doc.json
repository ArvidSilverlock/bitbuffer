[{"title":"Reader","type":0,"sectionRef":"#","url":"/bitbuffer/api/Reader","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#functions","content":" "},{"title":"Variadic​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#Variadic","content":"&lt;/&gt; Reader:Variadic( readCallback: &lt;T&gt;(self) → T, count: number-- The amount of values to read ) → ...T Reads any amount of values using one write function  "},{"title":"UInt​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#UInt","content":"&lt;/&gt; Reader:UInt( width: number-- The bit width to read ) → number Reads an unsigned integer of any width from 1-53  "},{"title":"Int​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#Int","content":"&lt;/&gt; Reader:Int(width: number) → number Reads a signed integer of any width from 1-53, note that one of these bits is used as the sign  "},{"title":"Boolean​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#Boolean","content":"&lt;/&gt; Reader:Boolean() → boolean Reads a boolean  "},{"title":"String​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#String","content":"&lt;/&gt; Reader:String( lengthWidth: number?-- Amount of bits to encode the string length with, defaults to 16 ) → string Reads a string that has its length encoded using a specified number of bits  "},{"title":"NullTerminatedString​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#NullTerminatedString","content":"&lt;/&gt; Reader:NullTerminatedString() → string Reads characters of a string until it encounters a byte with a value of 0  "},{"title":"Vector3​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#Vector3","content":"&lt;/&gt; Reader:Vector3() → Vector3  Reads a Vector3 using 3 Float32s  "},{"title":"Vector3int16​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#Vector3int16","content":"&lt;/&gt; Reader:Vector3int16() → Vector3int16  Reads a Vector3int16 using 3 Int16s  "},{"title":"Vector2​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#Vector2","content":"&lt;/&gt; Reader:Vector2() → Vector2  Reads a Vector2 using 2 Float32s  "},{"title":"Vector2int16​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#Vector2int16","content":"&lt;/&gt; Reader:Vector2int16() → Vector2int16  Reads a Vector2int16 using 2 Float32s  "},{"title":"CFrame​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#CFrame","content":"&lt;/&gt; Reader:CFrame() → CFrame  Reads a CFrame using a 5 bit unsigned integer to specify an axis aligned case along with its Vector3 position, if the CFrame isn't axis aligned, it will read an XVector, YVector and, ZVector too  "},{"title":"BrickColor​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#BrickColor","content":"&lt;/&gt; Reader:BrickColor() → BrickColor  Reads a BrickColor using an 11 bit unsigned integer  "},{"title":"Color3​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#Color3","content":"&lt;/&gt; Reader:Color3() → Color3  Reads 3 bytes, one for each RGB component  "},{"title":"UDim​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#UDim","content":"&lt;/&gt; Reader:UDim() → UDim  Reads a UDim using a Float32 and Int32  "},{"title":"UDim2​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#UDim2","content":"&lt;/&gt; Reader:UDim2() → UDim2  Reads a UDim2 using two UDims  "},{"title":"NumberRange​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#NumberRange","content":"&lt;/&gt; Reader:NumberRange() → NumberRange  Reads a NumberRange using two Float32s  "},{"title":"Enum​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#Enum","content":"&lt;/&gt; Reader:Enum( enumType: Enum? -- The EnumItem.Type that the read value should have ) → EnumItem  If no enumType is specified, it will read the EnumItem.Type, then read the EnumItem using unsigned integers whose widths depend on the amount of possible values.  "},{"title":"ColorSequence​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#ColorSequence","content":"&lt;/&gt; Reader:ColorSequence() → ColorSequence  Reads a ColorSequence using an unsigned 5 bit integer for the length, then a Float32 for the Time and a Color3 for the Value of each keypoint  "},{"title":"NumberSequence​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#NumberSequence","content":"&lt;/&gt; Reader:NumberSequence( readEnvelope: boolean?-- Whether or not to read the value of the Envelope ) → NumberSequence  Reads a NumberSequence using an unsigned 5 bit integer for the length, then a Float32 for the Time, Value and Envelope of each keypoint  "},{"title":"UInt8​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#UInt8","content":"&lt;/&gt; Reader:UInt8() → number Reads an 8 bit unsigned integer  "},{"title":"UInt16​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#UInt16","content":"&lt;/&gt; Reader:UInt16() → number Reads an 16 bit unsigned integer  "},{"title":"UInt24​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#UInt24","content":"&lt;/&gt; Reader:UInt24() → number Reads an 24 bit unsigned integer  "},{"title":"UInt32​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#UInt32","content":"&lt;/&gt; Reader:UInt32() → number Reads an 32 bit unsigned integer  "},{"title":"UInt8​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#UInt8","content":"&lt;/&gt; Reader:UInt8() → number Reads an 8 bit integer  "},{"title":"UInt16​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#UInt16","content":"&lt;/&gt; Reader:UInt16() → number Reads a 16 bit integer  "},{"title":"Int8​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#Int8","content":"&lt;/&gt; Reader:Int8() → number Reads a 24 bit integer  "},{"title":"Int32​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#Int32","content":"&lt;/&gt; Reader:Int32() → number Reads a 32 bit integer  "},{"title":"Float16​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#Float16","content":"&lt;/&gt; Reader:Float16() → number Reads a half-precision floating point number  "},{"title":"Float32​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#Float32","content":"&lt;/&gt; Reader:Float32() → number Reads a single-precision floating point number  "},{"title":"Float64​","type":1,"pageTitle":"Reader","url":"/bitbuffer/api/Reader#Float64","content":"&lt;/&gt; Reader:Float64() → number Reads a double-precision floating point number "},{"title":"bitbuffer","type":0,"sectionRef":"#","url":"/bitbuffer/api/bitbuffer","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"bitbuffer","url":"/bitbuffer/api/bitbuffer#functions","content":" "},{"title":"read​","type":1,"pageTitle":"bitbuffer","url":"/bitbuffer/api/bitbuffer#read","content":"&lt;/&gt; bitbuffer.read( b: buffer,-- The buffer to read from offset: number,-- The offset (in bits) to read from width: number-- The width (in bits) of the value you're reading ) → () Reads a value from a buffer in big endian format.  "},{"title":"write​","type":1,"pageTitle":"bitbuffer","url":"/bitbuffer/api/bitbuffer#write","content":"&lt;/&gt; bitbuffer.write( b: buffer,-- The buffer to write to offset: number,-- The offset (in bits) to write at value: number,-- The value you want to write width: number-- The width (in bits) of the value ) → () Writes a value into a buffer in big endian format.  "},{"title":"readlittle​","type":1,"pageTitle":"bitbuffer","url":"/bitbuffer/api/bitbuffer#readlittle","content":"&lt;/&gt; bitbuffer.readlittle( b: buffer,-- The buffer to read from offset: number,-- The offset (in bits) to read from width: number-- The width (in bits) of the value you're reading ) → () Reads a value from a buffer in little endian format.  "},{"title":"writelittle​","type":1,"pageTitle":"bitbuffer","url":"/bitbuffer/api/bitbuffer#writelittle","content":"&lt;/&gt; bitbuffer.writelittle( b: buffer,-- The buffer to write to offset: number,-- The offset (in bits) to write at value: number,-- The value you want to write width: number-- The width (in bits) of the value ) → () Writes a value into a buffer in little endian format.  "},{"title":"tobinary​","type":1,"pageTitle":"bitbuffer","url":"/bitbuffer/api/bitbuffer#tobinary","content":"&lt;/&gt; bitbuffer.tobinary( b: buffer,-- The buffer to convert to a string separator: string?,-- The string to separate each byte with, if not specified, each byte is separated by an underscore. prefix: (string | boolean)?,-- If prefix is true, it will be prefixed with 0b, whereas if it is a string, the string itself will be used. useLittleEndian: boolean?-- Whether or not to output it in little endian format. ) → string Converts a given buffer to a binary string.  "},{"title":"frombinary​","type":1,"pageTitle":"bitbuffer","url":"/bitbuffer/api/bitbuffer#frombinary","content":"&lt;/&gt; bitbuffer.frombinary( str: string-- The string to convert into a buffer ) → buffer Converts a given binary string into a buffer. No characters besides 1 and 0 may be present.  "},{"title":"tohex​","type":1,"pageTitle":"bitbuffer","url":"/bitbuffer/api/bitbuffer#tohex","content":"&lt;/&gt; bitbuffer.tohex( b: buffer,-- The buffer to convert to a string separator: string?,-- The string to separate each byte with, if not specified, each byte is separated by a space. prefix: (string | boolean)?,-- If prefix is true, it will be prefixed with 0x, whereas if it is a string, the string itself will be used. useLittleEndian: boolean?-- Whether or not to output it in little endian format. ) → string Converts a given buffer to a hexadecimal string.  "},{"title":"fromhex​","type":1,"pageTitle":"bitbuffer","url":"/bitbuffer/api/bitbuffer#fromhex","content":"&lt;/&gt; bitbuffer.fromhex( str: string-- The string to convert into a buffer ) → buffer Converts a given hexadecimal string into a buffer. No characters besides hexadecimal characters may be present.  "},{"title":"tobase64​","type":1,"pageTitle":"bitbuffer","url":"/bitbuffer/api/bitbuffer#tobase64","content":"&lt;/&gt; bitbuffer.tobase64( b: buffer,-- The buffer to convert to a string separator: string?,-- The string to separate every 6 bits with, if not specified, no separator will be used. prefix: string?-- The string to prefix the output with. ) → string Converts a given buffer to a binary string.  "},{"title":"frombase64​","type":1,"pageTitle":"bitbuffer","url":"/bitbuffer/api/bitbuffer#frombase64","content":"&lt;/&gt; bitbuffer.frombase64( str: string-- The string to convert into a buffer ) → buffer Converts a given base64 string into a buffer.  "},{"title":"reader​","type":1,"pageTitle":"bitbuffer","url":"/bitbuffer/api/bitbuffer#reader","content":"&lt;/&gt; bitbuffer.reader( b: buffer,-- The buffer to read from useLittleEndian: boolean-- Whether to read values in little endian ) → buffer Creates a Reader object for a buffer.  "},{"title":"writer​","type":1,"pageTitle":"bitbuffer","url":"/bitbuffer/api/bitbuffer#writer","content":"&lt;/&gt; bitbuffer.writer( b: buffer,-- The buffer to write to useLittleEndian: boolean-- Whether to write values in little endian ) → buffer Creates a Writer object for a buffer. "},{"title":"Writer","type":0,"sectionRef":"#","url":"/bitbuffer/api/Writer","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#functions","content":" "},{"title":"Variadic​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Variadic","content":"&lt;/&gt; Writer:Variadic( writeCallback: &lt;T&gt;( self, value: T ) → (), ...: T ) → () Writes any amount of values using one write function  "},{"title":"UInt​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#UInt","content":"&lt;/&gt; Writer:UInt( value: number,-- The uint to write width: number-- The bit width of the value ) → () Writes an unsigned integer of any width from 1-53  "},{"title":"Int​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Int","content":"&lt;/&gt; Writer:Int( value: number, width: number ) → () Writes a signed integer of any width from 1-53, note that one of these bits is used as the sign  "},{"title":"Boolean​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Boolean","content":"&lt;/&gt; Writer:Boolean(value: boolean) → () Writes a boolean  "},{"title":"String​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#String","content":"&lt;/&gt; Writer:String( value: string, lengthWidth: number?-- Amount of bits to encode the string length with, defaults to 16 ) → () Writes a string with its length encoded using a specified number of bits  "},{"title":"NullTerminatedString​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#NullTerminatedString","content":"&lt;/&gt; Writer:NullTerminatedString(value: string) → () Writes a string until it finds a character with the value of 0, if one is not found, it will write one on the end  "},{"title":"Vector3​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Vector3","content":"&lt;/&gt; Writer:Vector3(value: Vector3 ) → () Writes a Vector3 using 3 Float32s  "},{"title":"Vector3int16​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Vector3int16","content":"&lt;/&gt; Writer:Vector3int16(value: Vector3int16 ) → () Writes a Vector3int16 using 3 Int16s  "},{"title":"Vector2​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Vector2","content":"&lt;/&gt; Writer:Vector2(value: Vector2 ) → () Writes a Vector2 using 2 Int32s  "},{"title":"Vector2int16​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Vector2int16","content":"&lt;/&gt; Writer:Vector2int16(value: Vector2int16 ) → () Writes a Vector2int16 using 2 Int16s  "},{"title":"CFrame​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#CFrame","content":"&lt;/&gt; Writer:CFrame(value: CFrame ) → () Writes a CFrame using a 5 bit unsigned integer to specify an axis aligned case along with its Vector3 position, if the CFrame isn't axis aligned, it will encode the XVector, YVector and, ZVector too  "},{"title":"BrickColor​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#BrickColor","content":"&lt;/&gt; Writer:BrickColor(value: BrickColor ) → () Writes a BrickColor using an 11 bit unsigned integer  "},{"title":"Color3​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Color3","content":"&lt;/&gt; Writer:Color3(value: Color3 ) → () Writes 3 bytes, one for each RGB component  "},{"title":"UDim​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#UDim","content":"&lt;/&gt; Writer:UDim(value: UDim ) → () Writes a UDim using a Float32 and Int32  "},{"title":"UDim2​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#UDim2","content":"&lt;/&gt; Writer:UDim2(value: UDim2 ) → () Writes a UDim2 using two UDims  "},{"title":"NumberRange​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#NumberRange","content":"&lt;/&gt; Writer:NumberRange(value: NumberRange ) → () Writes a NumberRange using two Float32s  "},{"title":"Enum​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Enum","content":"&lt;/&gt; Writer:Enum( value: EnumItem , enumType: Enum? -- If specified, it will skip the encoding of the EnumType ) → () If no enumType is specified, it will encode the EnumItem.Type, then encode the EnumItem using unsigned integers whose widths depend on the amount of possible values. This is good for short term usage, such as sending over the network, but, bad for long term storage (i.e., storing in a datastore), this is because a roblox update might add aditional Enums or EnumItems, altering the required value widths  "},{"title":"ColorSequence​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#ColorSequence","content":"&lt;/&gt; Writer:ColorSequence(value: ColorSequence ) → () Encodes a ColorSequence using an unsigned 5 bit integer for the length, then a Float32 for the Time and a Color3 for the Value of each keypoint  "},{"title":"NumberSequence​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#NumberSequence","content":"&lt;/&gt; Writer:NumberSequence( value: NumberSequence , writeEnvelope: boolean?-- Whether or not to include the Envelope in the output ) → () Encodes a NumberSequence using an unsigned 5 bit integer for the length, then a Float32 for the Time, Value and Envelope of each keypoint  "},{"title":"UInt8​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#UInt8","content":"&lt;/&gt; Writer:UInt8(value: number) → () Writes an 8 bit unsigned integer  "},{"title":"UInt16​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#UInt16","content":"&lt;/&gt; Writer:UInt16(value: number) → () Writes a 16 bit unsigned integer  "},{"title":"UInt24​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#UInt24","content":"&lt;/&gt; Writer:UInt24(value: number) → () Writes a 24 bit unsigned integer  "},{"title":"UInt32​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#UInt32","content":"&lt;/&gt; Writer:UInt32(value: number) → () Writes a 32 bit unsigned integer  "},{"title":"Int8​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Int8","content":"&lt;/&gt; Writer:Int8(value: number) → () Writes an 8 bit signed integer  "},{"title":"Int16​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Int16","content":"&lt;/&gt; Writer:Int16(value: number) → () Writes a 16 bit signed integer  "},{"title":"Int24​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Int24","content":"&lt;/&gt; Writer:Int24(value: number) → () Writes a 24 bit signed integer  "},{"title":"Int32​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Int32","content":"&lt;/&gt; Writer:Int32(value: number) → () Writes a 32 bit signed integer  "},{"title":"Float16​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Float16","content":"&lt;/&gt; Writer:Float16(value: number) → () Writes a half-precision floating point number  "},{"title":"Float32​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Float32","content":"&lt;/&gt; Writer:Float32(value: number) → () Writes a single-precision floating point number  "},{"title":"Float64​","type":1,"pageTitle":"Writer","url":"/bitbuffer/api/Writer#Float64","content":"&lt;/&gt; Writer:Float64(value: number) → () Writes a double-precision floating point number "}]