"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[331],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>c});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},f="mdxType",b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),f=s(n),d=a,c=f["".concat(p,".").concat(d)]||f[d]||b[d]||i;return n?r.createElement(c,o(o({ref:t},u),{},{components:n})):r.createElement(c,o({ref:t},u))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[f]="string"==typeof e?e:a,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},76647:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>o,default:()=>f,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=n(87462),a=(n(67294),n(3905));const i={},o="bitbuffer",l={type:"mdx",permalink:"/bitbuffer/",source:"@site/pages/index.md",title:"bitbuffer",description:"Bit level manipulation of roblox's byte level buffers.",frontMatter:{}},p=[{value:"API",id:"api",level:2},{value:"Base Conversion API",id:"base-conversion-api",level:2},{value:"Writing non UInts",id:"writing-non-uints",level:2},{value:"An few examples",id:"an-few-examples",level:2},{value:"TODO:",id:"todo",level:2}],s={toc:p},u="wrapper";function f(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"bitbuffer"},"bitbuffer"),(0,a.kt)("p",null,"Bit level manipulation of roblox's byte level buffers. \ud83d\ude0e\nAs of right now, only supports ",(0,a.kt)("inlineCode",{parentName:"p"},"uints"),"."),(0,a.kt)("h2",{id:"api"},"API"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"read(buffer, offset, width)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"write(buffer, offset, value, width)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"readlittle(buffer, offset, width)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"writelittle(buffer, offset, value, width)"))),(0,a.kt)("p",null,"The offset that each function requires is a 0 indexed ",(0,a.kt)("em",{parentName:"p"},"bit")," ",(0,a.kt)("inlineCode",{parentName:"p"},"offset"),", the ",(0,a.kt)("inlineCode",{parentName:"p"},"width")," is also in bits, which can range from 1-48, the ",(0,a.kt)("inlineCode",{parentName:"p"},"value")," is an unsigned integer."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"read")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"write")," use big endian, whereas ",(0,a.kt)("inlineCode",{parentName:"p"},"readlittle")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"writelittle")," use little endian. ",(0,a.kt)("inlineCode",{parentName:"p"},"readlittle")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"writelittle")," are faster than their big endian counterparts as roblox's ",(0,a.kt)("inlineCode",{parentName:"p"},"buffer")," objects seemingly use little endian on the byte scale, therefore less manipulation of the buffers is required. I'm not all too sure on any of this, as I'm not educated on the subject of endianness."),(0,a.kt)("h2",{id:"base-conversion-api"},"Base Conversion API"),(0,a.kt)("p",null,"Currently there are 3 supported bases, binary, hexadecimal, and base64, each of which have ",(0,a.kt)("inlineCode",{parentName:"p"},"to")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"from")," functions."),(0,a.kt)("p",null,"Functions that convert ",(0,a.kt)("em",{parentName:"p"},"to")," a base intake a buffer and return a string, whereas the functions that do the inverse intake a string and return a buffer.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"from")," functions ",(0,a.kt)("em",{parentName:"p"},"do not")," support prefixes or separators, this may come in the future, we'll have to see."),(0,a.kt)("p",null,"Each of the ",(0,a.kt)("inlineCode",{parentName:"p"},"to")," functions take 3 parameters, the first being the buffer to convert, the second being the separator between each code, and the third being a prefix (or a boolean defining whether or not to add the default prefix). Only the first parameter is required, if the others aren't specified it will use defaults that make sense for each base."),(0,a.kt)("p",null,"For byte aligned functions, such as ",(0,a.kt)("inlineCode",{parentName:"p"},"tobinary")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"tohex"),", you are allowed to specify whether or not to flip the endian of the bytes being read, this is useful if you are using the little endian ",(0,a.kt)("inlineCode",{parentName:"p"},"read")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"write")," calls and want to debug."),(0,a.kt)("p",null,"An example of how these format functions could look"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'print(bitbuffer.tobinary(b)) -- 11110011_10100110_00110100_01011010\nprint(bitbuffer.tobinary(b, " ")) -- 11110011 10100110 00110100 01011010\n\nprint(bitbuffer.tohex(b)) -- f3 a6 34 5a\nprint(bitbuffer.tohex(b, "")) -- f3a6345a\n\nprint(bitbuffer.tobase64(b)) -- 86Y0Wg==\n\n-- You can do this trick to easily copy paste the actual number values for debugging.\nprint(bitbuffer.tobinary(b, ", 0b", true)) -- 0b11110011, 0b10100110, 0b00110100, 0b01011010\nprint(bitbuffer.tohex(b, ", 0x", true)) -- 0xf3, 0xa6, 0x34, 0x5a\n')),(0,a.kt)("h2",{id:"writing-non-uints"},"Writing non UInts"),(0,a.kt)("p",null,"If you want to write values other than UInts, you could possibly use ",(0,a.kt)("inlineCode",{parentName:"p"},"string.pack")," to convert non UInts to UInts, for example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'print(string.unpack("<I4", string.pack("<f", math.pi))) -- 1078530011\n')),(0,a.kt)("p",null,"You can easily invert this process by flipping the pack formats around."),(0,a.kt)("p",null,"Obviously this is relatively slow, but I'm not all too sure if there's an alternative to doing this, as there's not really another way to read binary data."),(0,a.kt)("h2",{id:"an-few-examples"},"An few examples"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"local b = buffer.create(1)\n\nbitbuffer.write(b, 0, 1, 1) -- Write 1 bit at the first bit.\nassert(bitbuffer.read(b, 0, 1) == 1) -- Validate the write call functioned as expected\n\nprint(bitbuffer.tobinary(b)) -- 10000000\nprint(bitbuffer.tohex(b)) -- 80\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local b = buffer.fromstring("foobar")\n\nlocal encoded = bitbuffer.tobase64(b, "")\nlocal decoded = bitbuffer.frombase64(encoded)\n\nassert(bitbuffer.tohex(b) == bitbuffer.tohex(decoded))\n\nprint(encoded) -- Zm9vYmFy\n')),(0,a.kt)("h2",{id:"todo"},"TODO:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"some form of function that allows for better formatting like ",(0,a.kt)("inlineCode",{parentName:"li"},"0000 000000 00000000")," (i.e., chunks of information are split into groups specified by the user, good if you have a set scheme for your data)"),(0,a.kt)("li",{parentName:"ul"},"given the nature of this module, testez is probably a good idea")))}f.isMDXComponent=!0}}]);